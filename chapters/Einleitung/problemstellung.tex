\section{Problemstellung}

Threads findet man in allen Programmen heutzutage. Auch schon die Ausführung eines einfachen Java Programms ohne Multithreading erstellt nicht nur einen Thread für das Main Programm, sondern auch ein weiterer für die Garbage Collection. Auch Servelets, wie zum Beispiel Spring Boot, erstellen für jede Anfrage eines HTTP Clients einen eigenen Thread, so dass mehrere Nutzer gleichzeitig die gleiche Schnittstelle aufrufen können \cite[vgl.][8]{brian}.

Multithreading bietet durch die Parallelisierung der Aufgaben Vorteile, beispielsweise das komplexe Anwendungen bessere Leistung haben \cite[vgl.][3]{brian}. 

Die durch Multithreading erlangte Leistung bringt aber auch einen großen Nachteil mit sich. Durch das parallele Aufrufen des selben Programms können mehrere Threads gleichzeitig auf die gleiche Ressource zugreifen. Wenn alle Operationen der Threads auf dieselbe Variable nur Leseoperationen sind besteht zunächst kein Problem, dies wäre zum Beispiel in Java  bei einer \texttt{final} Variable der Fall, die read only ist. Probleme entstehen dann, wenn eine der Operationen schreiben ist. Bei schlechtem Timing kann es zum Beispiel zu dem Problem kommen, dass eine Ressource von zwei Threads gleichzeitig beschrieben wird, wodurch eine Inkonsistenz in den Daten entsteht \cite[vgl.][11-15]{brian}.      