\section{Problemstellung}

Threads findet man heutzutage in allen Programmen. Bereits bei der Ausführung eines einfachen Java Programms, erstellt Java nicht nur einen Thread für das Main Programm, sondern auch ein weiterer für die Garbage Collection. Auch Servelets, wie zum Beispiel Spring Boot, erstellen für jede Anfrage eines HTTP Clients einen eigenen Thread, sodass mehrere Nutzer gleichzeitig die gleiche Schnittstelle aufrufen können \cite[vgl.][8]{brian}.

Multithreading bietet durch die Parallelisierung der Aufgaben Vorteile, beispielsweise das komplexe Anwendungen bessere Leistung haben \cite[vgl.][3]{brian}. 

Die durch Multithreading erlangte Leistung bringt aber auch einen großen Nachteil mit sich. Durch das parallele Aufrufen des selben Programms können mehrere Threads parallel auf die gleiche Ressource zugreifen. Wenn alle Operationen der Threads auf dieselbe Variable nur Leseoperationen sind besteht zunächst kein Problem. Dies wäre zum Beispiel in Java  bei einer \texttt{final} Variable der Fall, die read only ist. Probleme entstehen dann, wenn mindestens eine der Operationen schreiben ist. Bei schlechtem Timing kann es zum Beispiel zu dem Problem kommen, dass eine Ressource von zwei Threads gleichzeitig beschrieben wird, wodurch eine Inkonsistenz in den Daten entsteht \cite[vgl.][11-15]{brian}.      