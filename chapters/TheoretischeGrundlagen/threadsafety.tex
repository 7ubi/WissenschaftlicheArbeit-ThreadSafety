\section{Thread Safety}\label{sec:threadSafety}

$"$A class is thread-safe if it behaves correctly when accessed from multiple threads, regardless of the scheduling or interleaving of the execution of those threads by the runtime environment, and with no additional synchronization or other coordination on the part of the calling code$"$ \cite[12]{brian}.

%\begin{comment}
\begin{lstlisting}[language=Java,frame=tb,caption={Non-thread-safe Sequence Generator \cite{brian}}, label={lst:threadSafety}, numbers=left, stepnumber=1]
public class UnsafeSequenz {
	private int value;

	public int getNext() {
		return value++;
	}
}
\end{lstlisting}
%\end{comment}

\subsection*{Data Race}

Data Races\footnote{Data Races werden in \cite{brian} Safety Hazards genannt} entstehen, wenn zwei Threads gleichzeitig auf eine Ressource im Shared Memory zugreifen und mindestens eine der Operation beim Zugriff eine Schreib Operation ist \cite[vgl.][72]{banerjee_theory_2006}. 

Als Beispiel hierfür dient der Quellcode \ref{lst:threadSafety}. Wenn zwei Threads, durch schlechtes Timing, auf die Funktion \texttt{getNext()} zugreifen, kann in beiden Fällen die gleiche Zahl zurück gegeben werden. Dies ist möglich, da es sich bei Operation \texttt{value++} nicht eine Operation, sondern um drei Unterschiedliche handelt. Zunächst holt man sich den momentanen Integer, der in \texttt{value} steht. Danach addiert man eins auf \texttt{value} und schreibt den neuen Wert für \texttt{value} zurück. Das Problem ist, dass bei schlechtem Timing am Anfang vorkommen kann, dass die gleiche Zahl genutzt wird, wodurch am Ende die selbe Zahl zurückgegeben wird \cite[vgl.][5]{brian}.

